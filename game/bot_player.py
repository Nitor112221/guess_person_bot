from dataclasses import dataclass
import json
import os
from typing import List, Tuple, Dict, Any

from dotenv import load_dotenv
from openai import OpenAI

load_dotenv()
YANDEX_CLOUD_FOLDER = os.getenv("YANDEX_CLOUD_FOLDER")
YANDEX_CLOUD_API_KEY = os.getenv("YANDEX_CLOUD_API_KEY")
AI_client = OpenAI(
    api_key=YANDEX_CLOUD_API_KEY,
    base_url="https://llm.api.cloud.yandex.net/v1",
    project=YANDEX_CLOUD_FOLDER
)


@dataclass
class ResponseQuestion:
    question: str
    is_guess: bool


class BotPlayer:
    """Игрок-бот с искусственным интеллектом"""

    def __init__(self, bot_id: int, role: str):
        self.id = bot_id  # Отрицательный ID для ботов
        self.history: List[Tuple[str, str]] = list()
        self.assigned_role: str = ""  # Роль, которая назначена боту (скрыта от него)

    def ask(self) -> ResponseQuestion:
        """
        Формирует новый вопрос для угадывания персонажа на основе истории предыдущих вопросов и ответов.
        """

        # Формирование промпта для нейросети на основе истории
        prompt = """Ты играешь в игру "Угадай персонажа". Тебе загадали конкретного персонажа, но ты не знаешь его имени.
Твоя задача - угадать своего персонажа, задавая вопросы, на которые можно ответить только "да" или "нет".
Каждый вопрос может начинаться с фразы "Мой персонаж" и касаться характеристик персонажа.
Длина каждого вопроса НЕ МОЖЕТ ПРЕВЫШАТЬ 15 СЛОВ.

**СТРАТЕГИЧЕСКАЯ ЛОГИКА АНАЛИЗА ИСТОРИИ:**
Перед тем как задать следующий вопрос, проанализируй историю по следующим принципам:

1. **ПРИНЦИП РАСШИРЕНИЯ УСПЕХА (РАЗВИТИЕ "ДА"):**
   - Если получил ответ "да" на общую категорию - задавай более конкретные вопросы в этой же категории
   - Пример: "Мой персонаж появляется в фильмах?" → "да" → "Мой персонаж главный герой фильма?" → "да" → "Мой персонаж из голливудских фильмов?"

2. **ПРИНЦИП ИСКЛЮЧЕНИЯ ТУПИКОВ (ИЗБЕГАНИЕ "НЕТ"):**
   - Если получил ответ "нет" на категорию - полностью исключи эту тему из дальнейших вопросов
   - Пример: "Мой персонаж историческое лицо?" → "нет" → НЕ задавай вопросов про исторические эпохи, годы жизни и т.д.
   - Пример: "Мой персонаж из видеоигр?" → "нет" → НЕ задавай вопросов про игровые жанры, платформы, студии разработчиков

3. **ПРИНЦИП ЭФФЕКТИВНОЙ ГРУППИРОВКИ:**
   - Группируй похожие варианты в один вопрос ТОЛЬКО когда они принадлежат к одной общей категории
   - Пример правильной группировки: "Мой персонаж спортсмен из футбола, баскетбола или тенниса?"
   - Пример НЕПРАВИЛЬНОЙ группировки: "Мой персонаж футболист или ученый?" (слишком разные категории)

4. **ПРИНЦИП ДИАГНОСТИЧЕСКИХ ВОПРОСОВ:**
   - Каждый новый вопрос должен максимально уменьшать количество возможных персонажей
   - Задавай вопросы, которые проверяют КРИТИЧЕСКИЕ характеристики (те, что делят множество персонажей примерно пополам)

**КРИТИЧЕСКИЙ АНАЛИЗ ИСТОРИИ:**
Проанализируй историю и ответь себе на вопросы:
1. Какие категории получили "да"? КАК МОЖНО РАСШИРИТЬ эти темы?
2. Какие категории получили "нет"? КАК ПОЛНОСТЬЮ ИЗБЕЖАТЬ этих тем?
3. Есть ли в истории закономерности? Например: несколько "да" в области кино → вероятно, это киноперсонаж
4. Какие ВАЖНЫЕ характеристики еще не проверены? (пол, профессия, эпоха, страна происхождения, медиасреда)

**СТРАТЕГИЧЕСКИЕ ПРАВИЛА:**
- НИКОГДА не возвращайся к теме, на которую уже получил "нет"
- АКТИВНО развивай тему, на которую получил "да"
- Если в истории много "да" в одной области - углубляйся в эту область
- Если в истории много "нет" - ищи НОВЫЕ, еще не проверенные категории
- Избегай вопросов, ответы на которые можно ЛОГИЧЕСКИ вывести из истории

**ФОРМАТ ВОПРОСОВ:**
- Вопрос: начинается с "Мой персонаж..." и заканчивается "?"
- Угадывание: начинается с "Я ...!" и заканчивается "!"
"""

        if self.history:
            prompt += "\n\n**ИСТОРИЯ ПРЕДЫДУЩИХ ВОПРОСОВ И ОТВЕТОВ:**\n"
            for i, (question, answer) in enumerate(self.history, 1):
                prompt += f"{i}. Вопрос: {question}\n   Ответ, который ты получал ранее на этот вопрос: {answer}\n"

            # Добавляем анализ эффективности
            prompt += "\n**АНАЛИЗ ИСТОРИИ И СТРАТЕГИЧЕСКИЕ ВЫВОДЫ:**\n"
            prompt += "Проанализируй всю историю выше и сделай выводы:\n"
            prompt += "1. Какие характеристики персонажа уже точно известны?\n"
            prompt += "2. Какие категории персонажей уже исключены?\n"
            prompt += "3. Какую информацию можно извлечь из ответов 'да' и 'нет'?\n"
            prompt += "4. Какие темы/категории требуют дополнительного уточнения?\n"
            prompt += "5. Исходя из истории, какие персонажи могут быть вероятными кандидатами?\n\n"

            prompt += "**ПРАВИЛО АНАЛИЗА:**"
            prompt += "Не задавай вопросы, на которые ответ уже содержится в истории (явно или косвенно). "

        prompt += """\n**ПРИНЯТЬ РЕШЕНИЕ НА ОСНОВЕ АНАЛИЗА ИСТОРИИ:**
    1. Если анализ истории дает тебе достаточно информации для точного предположения - попробуй угадать персонажа (используя формат "Я [имя]!")
    2. Если информации из истории недостаточно для точного угадывания - задай следующий стратегический вопрос (начиная с "Мой персонаж")

    **РЕШЕНИЕ О ВОПРОСЕ ИЛИ УГАДЫВАНИИ:**
- Угадывай ТОЛЬКО если можешь назвать КОНКРЕТНОГО персонажа, который очень соответствует многим "да" и малому числу "нет" из истории
- Если есть хоть одно несоответствие - задавай уточняющий вопрос
- Ответы на запросы могут иногда врать, но такие случаи редки

    Верни ответ ТОЛЬКО в формате JSON без каких-либо дополнительных пояснений:
    {"question": "твой_вопрос_или_предположение_здесь", "is_guess": 0 или 1}"""

        try:
            # Отправка запроса к модели
            json_schema = {
                "type": "object",
                "properties": {
                    "question": {"type": "string", "description": "Вопрос или предположение о персонаже"},
                    "is_guess": {"type": "integer",
                                 "description": "0 - если задается вопрос, 1 - если пытается угадать"},
                },
                "required": ["question", "is_guess"]
            }
            response = AI_client.chat.completions.create(
                model=f"gpt://{YANDEX_CLOUD_FOLDER}/yandexgpt/latest",
                messages=[
                    {"role": "system",
                     "content": "Ты - стратегический игрок в игре 'Угадай персонажа'. Твоя главная задача - тщательно анализировать историю предыдущих вопросов и ответов. Каждое твое решение должно основываться на анализе всей накопленной информации. Используй стратегию бинарного поиска, группировки и логических выводов из истории."},
                    {"role": "user", "content": prompt}
                ],
                temperature=0.9,
                max_tokens=350,  # Увеличил лимит для более сложных аналитических вопросов
                stream=False,
                response_format={"type": "json_schema", "json_schema": json_schema}
            )

            # Извлечение текста ответа
            response_text = response.choices[0].message.content.strip()

            # Извлечение JSON из ответа
            start_idx = response_text.find('{')
            end_idx = response_text.rfind('}') + 1

            if start_idx != -1 and end_idx != 0:
                json_str = response_text[start_idx:end_idx]
                result = json.loads(json_str)
            else:
                # Если не удалось найти JSON, создаём стандартный вопрос
                result = {
                    "question": "Мой персонаж мужского пола?",
                    "is_guess": 0
                }

            # Проверка и корректировка формата
            question_text = result.get("question", "").strip()

            # Определяем, является ли это попыткой угадать
            is_guess_attempt = question_text.startswith("Я ") and question_text.endswith("!")

            # Синхронизируем is_guess с форматом вопроса
            if is_guess_attempt:
                result["is_guess"] = 1
            else:
                # Если это не попытка угадать, но вопрос не в правильном формате - исправляем
                if question_text and not question_text.startswith("Мой персонаж"):
                    # Если вопрос начинается не с "Мой персонаж", добавляем префикс
                    if not question_text.endswith("?"):
                        result["question"] = f"Мой персонаж {question_text}?"
                    else:
                        result["question"] = f"Мой персонаж {question_text}"
                result["is_guess"] = 0

            # Проверка наличия обязательных полей
            if "question" not in result:
                result["question"] = "Мой персонаж мужского пола?"

            if "is_guess" not in result:
                result["is_guess"] = 0

            # Убедимся, что is_guess - целое число 0 или 1
            result["is_guess"] = int(bool(result["is_guess"]))

            return ResponseQuestion(**result)

        except Exception as e:
            # В случае ошибки возвращаем стандартный вопрос
            print(f"Ошибка при обращении к API: {e}")
            return ResponseQuestion(**{
                "question": "Мой персонаж мужского пола?",
                "is_guess": 0
            })

    def ans_for_question(self, role: str, question: str) -> bool:
        """
        Ответ нейросети на вопрос пользователя о загаданном персонаже.
        """

        # Формируем промпт для нейросети
        prompt = f"""Ты играешь в игру "Угадай персонажа". 
    Пользователь пытается угадать персонажа: "{role}".

    Для этого он задал вопрос: "{question}"
    **ВАЖНО** вопрос может не оканчиваться знаком вопроса (?), но он всё равно будет являться вопросом
    Вопрос может задаваться о персонаже, например "Мой персонаж...", а может от лица персонажа "Я...". Обе формулировки корректны и должны быть обработаны одинаково
    На этот вопрос можно ответить только "да" или "нет".

    Твоя задача - ответить на вопрос пользователя, исходя из характеристик персонажа {role}.

    ОСОБЫЕ ПРАВИЛА ДЛЯ ГРУППИРОВАННЫХ ВОПРОСОВ:
    Если вопрос содержит несколько утверждений, соединенных союзом "или", или перечислением через запятую:
    1. Если ХОТЯ БЫ ОДНО из утверждений соответствует характеристикам персонажа {role}, ответь "да"
    2. Если ВСЕ утверждения НЕ соответствуют характеристикам персонажа {role}, ответь "нет"

    Примеры логики:
    1. Вопрос: "Мой персонаж известен как герой компьютерных игр Dota 2, Genshin Impact, World of Warcraft или The Legend of Zelda?"
       - Если персонаж "Артас" (герой World of Warcraft) → Ответ: "да"
       - Если персонаж = "Дилюк" (герой Genshin Impact) → Ответ: "да"
       - Если персонаж = "Гарри Поттер" (не из этих игр) → Ответ: "нет"

    2. Вопрос: "Я являюсь ученым, инженером, врачом или программистом?"
       - Если персонаж = "Альберт Эйнштейн" (ученый) → Ответ: "да"
       - Если персонаж = "Илон Маск" (инженер) → Ответ: "да"
       - Если персонаж = "Леонардо да Винчи" (художник) → Ответ: "нет"

    3. Вопрос: "Мой персонаж появляется в книгах, фильмах, комиксах или видеоиграх?"
       - Если персонаж = "Супермен" (есть в комиксах и фильмах) → Ответ: "да"
       - Если персонаж = "Марио" (есть в видеоиграх) → Ответ: "да"
       - Если персонаж = "Наполеон Бонапарт" (нет в этих медиа) → Ответ: "нет"

    ВАЖНО: 
    1. Отвечай только одним словом: "да" или "нет"
    2. Не добавляй никаких пояснений, комментариев или знаков препинания
    3. Если не уверен в ответе, основывайся на общеизвестных фактах о персонаже
    4. Отвечай максимально точно и правдиво
    5. Для группированных вопросов используй логику "ХОТЯ БЫ ОДНО утверждение верно" → "да"

    Твой ответ:"""

        try:
            # Отправляем запрос к модели Mistral через OpenRouter
            response = AI_client.chat.completions.create(
                model=f"gpt://{YANDEX_CLOUD_FOLDER}/qwen3-235b-a22b-fp8/latest",  # Используем доступную модель Mistral
                messages=[
                    {"role": "system",
                     "content": f"Ты - ассистент в игре 'Угадай персонажа'. Твоя задача - точно отвечать на вопросы о персонаже {role}. Для группированных вопросов: если хотя бы одно утверждение верно для персонажа, отвечай 'да', иначе 'нет'."},
                    {"role": "user", "content": prompt}
                ],
                temperature=0,  # Низкая температура для более детерминированных ответов
                max_tokens=10,  # Ограничиваем длину ответа
            )

            # Получаем ответ
            answer_text = response.choices[0].message.content.strip().lower()

            # Преобразуем ответ в булево значение
            if answer_text.startswith('да'):
                return True
            elif answer_text.startswith('нет'):
                return False
            else:
                # Если ответ не распознан, пытаемся найти ключевые слова
                if any(word in answer_text for word in ['yes', 'true', 'верно', 'правильно', 'correct']):
                    return True
                elif any(word in answer_text for word in ['no', 'false', 'неверно', 'неправильно', 'incorrect']):
                    return False
                else:
                    # По умолчанию возвращаем False при неоднозначном ответе
                    print(f"Неоднозначный ответ от нейросети: '{answer_text}'")
                    return False

        except Exception as e:
            print(f"Ошибка при обращении к API: {e}")
            # Возвращаем False в случае ошибки
            return False

    def add_fact(self, question: str, answer: bool):
        """Добавляет известный факт в историю"""
        self.history.append((question, "Да" if answer else "Нет"))

    def to_dict(self) -> Dict[str, Any]:
        """Конвертация в словарь"""
        return {
            "id": self.id,
            "role": self.assigned_role,
            "history": self.history,
            "is_bot": True
        }
