from dataclasses import dataclass
import json
import os
from typing import List, Tuple, Dict, Any

from dotenv import load_dotenv
from openai import OpenAI

load_dotenv()
YANDEX_CLOUD_FOLDER = os.getenv("YANDEX_CLOUD_FOLDER")
YANDEX_CLOUD_API_KEY = os.getenv("YANDEX_CLOUD_API_KEY")
# Инициализация клиента OpenAI с указанием базового URL
client = OpenAI(
    api_key=YANDEX_CLOUD_API_KEY,
    base_url="https://llm.api.cloud.yandex.net/v1",
    project=YANDEX_CLOUD_FOLDER
)

@dataclass
class ResponseQuestion:
    question: str
    is_guess: bool


class BotPlayer:
    """Игрок-бот с искусственным интеллектом"""

    def __init__(self, bot_id: int, role: str):
        self.id = bot_id  # Отрицательный ID для ботов
        self.history: List[Tuple[str, str]] = []
        self.assigned_role: str = ""  # Роль, которая назначена боту (скрыта от него)

    def ask(self) -> ResponseQuestion:
        """
        Формирует новый вопрос для угадывания персонажа на основе истории предыдущих вопросов и ответов.
        """

        # Формирование промпта для нейросети на основе истории
        prompt = """Ты играешь в игру "Угадай персонажа". У тебя загадан конкретный персонаж, но ты не знаешь его имени.
    Твоя задача - угадать своего персонажа, задавая вопросы, на которые можно ответить только "да" или "нет".
    Каждый вопрос должен начинаться с фразы "Мой персонаж" и касаться характеристик персонажа.
    Длина каждого вопроса НЕ МОЖЕТ ПРЕВЫШАТЬ 15 СЛОВ.

    **ВАЖНЕЙШИЙ ПРИНЦИП: ОПИРАЙСЯ НА ИСТОРИЮ И ТЩАТЕЛЬНО АНАЛИЗИРУЙ ЕЁ**
    Перед тем как задать следующий вопрос, внимательно проанализируй всю историю предыдущих вопросов и ответов:
    1. Выяви закономерности в ответах "да" и "нет"
    2. Определи, какие категории персонажей уже исключены
    3. Определи, какие характеристики персонажа уже известны
    4. Используй накопленную информацию для сужения круга возможных персонажей

    ЭФФЕКТИВНАЯ СТРАТЕГИЯ ВОПРОСОВ:
    Для уменьшения количества вопросов, ты можешь группировать похожие варианты в один вопрос.
    Вместо того чтобы задавать несколько отдельных вопросов о похожих характеристиках, объедини их в один.

    Примеры группировки:
    ВМЕСТО нескольких вопросов:
    1. "Мой персонаж известен как герой компьютерной игры Genshin Impact?"
    2. "Мой персонаж известен как герой компьютерной игры World of Warcraft?"
    3. "Мой персонаж известен как герой компьютерной игры The Legend of Zelda?"
    4. "Мой персонаж известен как герой компьютерной игры Dota 2?"

    МОЖНО задать 1 ОБЪЕДИНЕННЫЙ вопрос:
    "Мой персонаж известен как герой компьютерных игр Dota 2, Genshin Impact, World of Warcraft или The Legend of Zelda?"

    Еще примеры эффективных группированных вопросов:
    - "Мой персонаж имеет отношение к футболу, баскетболу, хоккею или теннису?"
    - "Мой персонаж является ученым, инженером, врачом или программистом?"
    - "Мой персонаж появляется в книгах, фильмах, комиксах или видеоиграх?"

    ВАЖНОЕ ПРАВИЛО ДЛЯ УГАДЫВАНИЯ:
    Если у тебя накопилось достаточно информации о персонаже и ты готов сделать предположение о том, кто это,
    ты МОЖЕШЬ попытаться угадать персонажа. В этом случае:
    1. Ты ДОЛЖЕН начать фразу с местоимения "Я"
    2. Ты ДОЛЖЕН указать имя персонажа в формате "Я [имя персонажа]!"
    3. Ты ДОЛЖЕН поставить восклицательный знак в конце (!)
    4. Пример правильной попытки угадать: "Я Шерлок Холмс!"

    ВСЕГДА СЛЕДУЙ ЭТИМ ПРАВИЛАМ:
    - Если ты задаешь вопрос о персонаже: "question" должен начинаться с "Мой персонаж...?"
    - Если ты пытаешься угадать персонажа: "question" должен начинаться с "Я [имя]!"
    - Если ты задаешь вопрос (ВОПРОС по персонажу): "is_guess" должен быть равен 0
    - Если ты пытаешься угадать (КЛЮЧЕВАЯ ФРАЗА "Я [персонаж]!"): "is_guess" должен быть равен 1

    Примеры правильных вопросов:
    1. "Мой персонаж мужского пола?"
    2. "Мой персонаж является реальным историческим лицом?"
    3. "Мой персонаж появляется в фильмах?"

    Примеры правильных попыток угадать:
    1. "Я Гарри Поттер!"
    2. "Я Наполеон Бонапарт!"
    3. "Я Микки Маус!" """

        if self.history:
            prompt += "\n\n**ИСТОРИЯ ПРЕДЫДУЩИХ ВОПРОСОВ И ОТВЕТОВ:**\n"
            for i, (question, answer) in enumerate(self.history, 1):
                prompt += f"{i}. Вопрос: {question}\n   Ответ, который ты получал: {answer}\n"

            # Добавляем анализ эффективности
            prompt += "\n**АНАЛИЗ ИСТОРИИ И СТРАТЕГИЧЕСКИЕ ВЫВОДЫ:**\n"
            prompt += "Проанализируй всю историю выше и сделай выводы:\n"
            prompt += "1. Какие характеристики персонажа уже точно известны?\n"
            prompt += "2. Какие категории персонажей уже исключены?\n"
            prompt += "3. Какую информацию можно извлечь из ответов 'да' и 'нет'?\n"
            prompt += "4. Какие темы/категории требуют дополнительного уточнения?\n"
            prompt += "5. Исходя из истории, какие персонажи могут быть вероятными кандидатами?\n\n"

            prompt += "**ПРАВИЛО АНАЛИЗА:** Каждый следующий вопрос должен быть логическим продолжением истории. "
            prompt += "Не задавай вопросы, на которые ответ уже содержится в истории (явно или косвенно). "
            prompt += "Если в истории есть несколько вопросов об одной категории, сгруппируй их в следующий вопрос.\n"
            prompt += "Используй группировку вариантов, чтобы быстрее сузить круг возможных персонажей на основе уже известной информации.\n"

        prompt += """\n**ПРИНЯТЬ РЕШЕНИЕ НА ОСНОВЕ АНАЛИЗА ИСТОРИИ:**
    1. Если анализ истории дает тебе достаточно информации для точного предположения - попробуй угадать персонажа (используя формат "Я [имя]!")
    2. Если информации из истории недостаточно для точного угадывания - задай следующий стратегический вопрос (начиная с "Мой персонаж")

    **СТРАТЕГИЧЕСКИЙ СОВЕТ ДЛЯ ВОПРОСА:** 
    - Опирайся на анализ истории - какие категории уже проверены, какие нет
    - Используй группировку похожих вариантов в один вопрос для эффективности
    - Задавай вопросы, которые делят множество возможных персонажей примерно пополам, учитывая уже известную информацию
    - Избегай задавать вопросы, ответы на которые можно предсказать из истории
    - Каждый следующий вопрос должен максимально использовать накопленные знания

    **ПРИНЯТЬ РЕШЕНИЕ:**
    - Если ты будешь задавать ВОПРОС по персонажу: установи "is_guess": 0
    - Если ты будешь пытаться УГАДАТЬ персонажа на основе анализа истории: установи "is_guess": 1

    **ГЛАВНОЕ ПРАВИЛО:** Твой следующий вопрос или попытка угадать ДОЛЖНЫ быть логическим продолжением всей предыдущей истории. 
    Не игнорируй информацию, которая уже была получена!

    Верни ответ ТОЛЬКО в формате JSON без каких-либо дополнительных пояснений:
    {"question": "твой_вопрос_или_предположение_здесь", "is_guess": 0 или 1}"""

        try:
            # Отправка запроса к модели
            json_schema = {
                "type": "object",
                "properties": {
                    "question": {"type": "string", "description": "Вопрос или предположение о персонаже"},
                    "is_guess": {"type": "integer",
                                   "description": "0 - если задается вопрос, 1 - если пытается угадать"},
                },
                "required": ["question", "is_guess"]
            }
            response = client.chat.completions.create(
                model=f"gpt://{YANDEX_CLOUD_FOLDER}/yandexgpt/latest",
                messages=[
                    {"role": "system",
                     "content": "Ты - стратегический игрок в игре 'Угадай персонажа'. Твоя главная задача - тщательно анализировать историю предыдущих вопросов и ответов. Каждое твое решение должно основываться на анализе всей накопленной информации. Используй стратегию бинарного поиска, группировки и логических выводов из истории."},
                    {"role": "user", "content": prompt}
                ],
                temperature=0.7,
                max_tokens=350,  # Увеличил лимит для более сложных аналитических вопросов
                stream=False,
                response_format={"type": "json_schema", "json_schema": json_schema}
            )

            # Извлечение текста ответа
            response_text = response.choices[0].message.content.strip()

            # Извлечение JSON из ответа
            start_idx = response_text.find('{')
            end_idx = response_text.rfind('}') + 1

            if start_idx != -1 and end_idx != 0:
                json_str = response_text[start_idx:end_idx]
                result = json.loads(json_str)
            else:
                # Если не удалось найти JSON, создаём стандартный вопрос
                result = {
                    "question": "Мой персонаж мужского пола?",
                    "is_guess": 0
                }

            # Проверка и корректировка формата
            question_text = result.get("question", "").strip()

            # Определяем, является ли это попыткой угадать
            is_guess_attempt = question_text.startswith("Я ") and question_text.endswith("!")

            # Синхронизируем is_guess с форматом вопроса
            if is_guess_attempt:
                result["is_guess"] = 1
            else:
                # Если это не попытка угадать, но вопрос не в правильном формате - исправляем
                if question_text and not question_text.startswith("Мой персонаж"):
                    # Если вопрос начинается не с "Мой персонаж", добавляем префикс
                    if not question_text.endswith("?"):
                        result["question"] = f"Мой персонаж {question_text}?"
                    else:
                        result["question"] = f"Мой персонаж {question_text}"
                result["is_guess"] = 0

            # Проверка наличия обязательных полей
            if "question" not in result:
                result["question"] = "Мой персонаж мужского пола?"

            if "is_guess" not in result:
                result["is_guess"] = 0

            # Убедимся, что is_guess - целое число 0 или 1
            result["is_guess"] = int(bool(result["is_guess"]))

            return ResponseQuestion(**result)

        except Exception as e:
            # В случае ошибки возвращаем стандартный вопрос
            print(f"Ошибка при обращении к API: {e}")
            return ResponseQuestion(**{
                "question": "Мой персонаж мужского пола?",
                "is_guess": 0
            })

    def ans_for_question(self, role: str, question: str) -> bool:
        """
        Ответ нейросети на вопрос пользователя о загаданном персонаже.
        """

        # Формируем промпт для нейросети
        prompt = f"""Ты играешь в игру "Угадай персонажа". 
    Пользователь загадал персонажа: "{role}".

    Пользователь задает вопрос: "{question}"
    На этот вопрос можно ответить только "да" или "нет".

    Твоя задача - ответить на вопрос пользователя, исходя из характеристик персонажа {role}.

    ОСОБЫЕ ПРАВИЛА ДЛЯ ГРУППИРОВАННЫХ ВОПРОСОВ:
    Если вопрос содержит несколько утверждений, соединенных союзом "или", или перечислением через запятую:
    1. Если ХОТЯ БЫ ОДНО из утверждений соответствует характеристикам персонажа {role}, ответь "да"
    2. Если ВСЕ утверждения НЕ соответствуют характеристикам персонажа {role}, ответь "нет"

    Примеры логики:
    1. Вопрос: "Мой персонаж известен как герой компьютерных игр Dota 2, Genshin Impact, World of Warcraft или The Legend of Zelda?"
       - Если {role} = "Артас" (герой World of Warcraft) → Ответ: "да"
       - Если {role} = "Дилюк" (герой Genshin Impact) → Ответ: "да"
       - Если {role} = "Гарри Поттер" (не из этих игр) → Ответ: "нет"

    2. Вопрос: "Мой персонаж является ученым, инженером, врачом или программистом?"
       - Если {role} = "Альберт Эйнштейн" (ученый) → Ответ: "да"
       - Если {role} = "Илон Маск" (инженер) → Ответ: "да"
       - Если {role} = "Леонардо да Винчи" (художник) → Ответ: "нет"

    3. Вопрос: "Мой персонаж появляется в книгах, фильмах, комиксах или видеоиграх?"
       - Если {role} = "Супермен" (есть в комиксах и фильмах) → Ответ: "да"
       - Если {role} = "Марио" (есть в видеоиграх) → Ответ: "да"
       - Если {role} = "Наполеон Бонапарт" (нет в этих медиа) → Ответ: "нет"

    ВАЖНО: 
    1. Отвечай только одним словом: "да" или "нет"
    2. Не добавляй никаких пояснений, комментариев или знаков препинания
    3. Если не уверен в ответе, основывайся на общеизвестных фактах о персонаже
    4. Отвечай максимально точно и правдиво
    5. Для группированных вопросов используй логику "ХОТЯ БЫ ОДНО утверждение верно" → "да"

    Твой ответ:"""

        try:
            # Отправляем запрос к модели Mistral через OpenRouter
            response = client.chat.completions.create(
                model=f"gpt://{YANDEX_CLOUD_FOLDER}/yandexgpt/latest",  # Используем доступную модель Mistral
                messages=[
                    {"role": "system",
                     "content": f"Ты - ассистент в игре 'Угадай персонажа'. Твоя задача - точно отвечать на вопросы о персонаже {role}. Для группированных вопросов: если хотя бы одно утверждение верно для персонажа, отвечай 'да', иначе 'нет'."},
                    {"role": "user", "content": prompt}
                ],
                temperature=0.1,  # Низкая температура для более детерминированных ответов
                max_tokens=10,  # Ограничиваем длину ответа
            )

            # Получаем ответ
            answer_text = response.choices[0].message.content.strip().lower()

            # Преобразуем ответ в булево значение
            if answer_text.startswith('да'):
                return True
            elif answer_text.startswith('нет'):
                return False
            else:
                # Если ответ не распознан, пытаемся найти ключевые слова
                if any(word in answer_text for word in ['yes', 'true', 'верно', 'правильно', 'correct']):
                    return True
                elif any(word in answer_text for word in ['no', 'false', 'неверно', 'неправильно', 'incorrect']):
                    return False
                else:
                    # По умолчанию возвращаем False при неоднозначном ответе
                    print(f"Неоднозначный ответ от нейросети: '{answer_text}'")
                    return False

        except Exception as e:
            print(f"Ошибка при обращении к API: {e}")
            # Возвращаем False в случае ошибки
            return False

    def add_fact(self, question: str, answer: bool):
        """Добавляет известный факт в историю"""
        self.history.append((question, "Да" if answer else "Нет"))

    def to_dict(self) -> Dict[str, Any]:
        """Конвертация в словарь"""
        return {
            "id": self.id,
            "role": self.assigned_role,
            "history": self.history,
            "is_bot": True
        }